<!DOCTYPE html>

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>WAT REPL - Run or compile WebAssembly text code online</title>
  <meta name="description" content="Online WebAssembly REPL for compiling and formatting WebAssembly text WAT code into binary directly in your browser. Fast, simple, and efficient. Multiple compiler choices.">
  <meta name="keywords" content="WebAssembly, WAT, WAST, WASM, online REPL, WebAssembly editor, WASM REPL, wabt, wat2wasm, wat compiler">

  <meta property="og:title" content="WebAssembly Text REPL">
  <meta property="og:description" content="Run and test WebAssembly WAT code online.">
  <meta property="og:url" content="https://dy.github.io/watr/docs/repl">
  <meta property="og:type" content="website">
  <!-- <meta property="og:image" content="https://dy.github.io/watr/docs/og-image.png"> -->

  <!-- <meta name="twitter:card" content="summary_large_image"> -->
  <meta name="twitter:title" content="WebAssembly Text REPL">
  <meta name="twitter:description" content="Fast, simple WebAssembly REPL for WAT code.">
  <!-- <meta name="twitter:image" content="https://dy.github.io/watr/docs/twitter-image.png"> -->

  <meta name="google" content="notranslate">

  <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "SoftwareApplication",
      "name": "WebAssembly Text REPL",
      "applicationCategory": "Developer Tool",
      "operatingSystem": "All",
      "url": "https://dy.github.io/watr/docs/repl",
      "description": "An online WebAssembly REPL for running and testing WAT code.",
      "offers": {
        "@type": "Offer",
        "price": "0",
        "priceCurrency": "USD"
      }
    }
  </script>

  <link rel="canonical" href="https://dy.github.io/watr/docs/repl">

  <link rel="stylesheet" href="./lib/reset.css" />

  <!-- Prevent FOUC for sprae directives -->
  <style>
    [\:each],
    [\:if],
    [\:else] {
      visibility: hidden
    }
  </style>

  <style>
    html,
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
    }

    body {
      font-family: sans-serif;
      font-optical-sizing: auto;
      font-weight: 400;
      font-style: normal;
      padding-bottom: 3rem;
      display: flex;
      flex-direction: column;
      height: 100%;
      position: relative;
    }

    a {
      color: silver;

      &:hover {
        color: black;
      }
    }

    button,
    select {
      height: 2rem;
      border: none;
      box-shadow: 0 1px 1px 1px gainsboro;
      border-radius: 3px;
      cursor: pointer;
    }

    button {
      white-space: nowrap;
      background: whitesmoke;
      min-width: 2rem;
      padding: 0 .5rem;

      &:hover {
        background: white;
      }

      &::before {
        content: attr(icon);
        font-size: 1rem;
      }
    }

    @media (max-width: 600px) {
      button {
        font-size: 0;
      }
    }

    pre,
    code,
    output {
      font-family: monospace;
      font-weight: 400;
      font-style: normal;
    }

    /* theme */
    :root {
      --success: inherit;
      --error: #dc3545;

      --data: #d6336c;
      --keyword: #2b69cc;
      --number: #37a2a5;
      --comment: #848d95;
      --annot: #6f42c1;
      --id: #953800;
    }

    /* Drag-drop overlay */
    body.dragover::after {
      content: 'üìÇ Drop .wat or .wasm file';
      position: fixed;
      inset: 0;
      background: rgba(43, 105, 204, 0.9);
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 2rem;
      z-index: 1000;
      pointer-events: none;
    }
  </style>
</head>

<body id="app" :ondrop="handleDrop" :ondragover="handleDragOver" :ondragleave="handleDragLeave">
  <header style="padding: 1rem 1rem 0.5rem; display: flex; gap: 1rem;">
    <h1 title="WebAssembly text REPL">WAT REPL</h1>
    <nav style="margin-left: auto; gap: 1rem; display: flex;">
      <a href="https://github.com/dy/watr" title="Source (github)">‚éá</a>
    </nav>
  </header>

  <nav style="display: flex; align-items: center; margin: 0 1rem; gap: 1rem;">
    <label for="example" title="Example">
      <select name="example" :value="example" :onchange="e => e.target.value === '_load' ? loadBinaryInput.click() : loadExample(e.target.value)">
        <option value="">Custom</option>
        <option value="hello">Hello World</option>
        <option value="loops">Loops</option>
        <option value="memory">Memory</option>
        <option value="table">Tables</option>
        <option value="fire">üî• Fire</option>
        <option value="maze">üéÆ Maze</option>
        <option value="quine">Quine</option>
        <option disabled>‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</option>
        <option value="_load">üìÇ Load file...</option>
      </select>
      <input type="file" accept=".wasm,.wat,.wast" :ref="loadBinaryInput" :onchange="loadFile" hidden>
    </label>

    <label for="compiler" title="Compiler">
      <select name="compiler" :value="compiler" :onchange="e => { compiler = e.target.value; recompile() }">
        <option value="watr" selected>watr</option>
        <option value="wast">wast (spec)</option>
        <option value="wabt">wat2wasm (wabt)</option>
        <option value="watc">wat-compiler</option>
        <option value="binaryen">binaryen</option>
      </select>
    </label>

    <button :onclick="toggleFormat()" :title="prettified ? 'Minify WAT source' : 'Prettify WAT source'" :aria-label="prettified ? 'Minify WAT code' : 'Prettify WAT code'" :icon="prettified ? 'üóúÔ∏è' : 'ü™∑'"><span
        :text="prettified ? ' minify' : ' prettify'"></span></button>

    <button style="margin-left: auto" :onclick="download()" title="Download WASM binary" aria-label="Download WASM binary" icon="üì•"> .wasm</button>
    <button :onclick="copyBase64()" title="Copy binary as base64 string" aria-label="Copy binary as base64 string" icon="üìë"> base64</button>
  </nav>

  <div id="container">
    <style>
      #container {
        display: flex;
        margin: 1rem;
        gap: 2rem
      }

      @media (max-width: 960px) {
        #container {
          flex-direction: column;
        }
      }
    </style>

    <div id="editor-wrapper">
      <pre id="line-numbers" :ref="lineNumbersEl" aria-hidden="true"></pre>
      <code id="source" :ref="initEditor"
        :onkeydown.capture.meta:onkeydown.capture.ctrl="handleKey"
        title="WebAssembly Text Format (WAT) code" aria-label="WebAssembly Text Format (WAT) code" lang="plaintext"></code>
    </div>
    <style>
      #editor-wrapper {
        display: flex;
        flex: 1;
        min-width: 0;
        position: relative;
        overflow: auto;
      }

      #line-numbers {
        padding: 0 0.5rem 0 0;
        margin: 0;
        text-align: right;
        color: var(--comment);
        user-select: none;
        font-family: monospace;
        line-height: inherit;
        border-right: 1px solid gainsboro;
        margin-right: 0.5rem;
        min-width: 2ch;
      }

      /* theme */
      #source {
        min-height: 2rem;
        position: relative;
        flex: 1;
        min-width: 0;

        &:empty::before {
          content: "Type your code here...";
          color: var(--comment);
        }

        .kw {
          color: var(--keyword);
          font-weight: 500;
        }

        .var {
          color: var(--id);
        }

        .num {
          color: var(--number);
        }

        .data {
          color: var(--data);
        }

        .comment {
          color: var(--comment);
          font-style: italic;
        }

        .annot {
          color: var(--annot);
        }

        .error-line {
          background: rgba(220, 53, 69, 0.15);
          display: inline-block;
          width: 100%;
          margin: 0 -0.25rem;
          padding: 0 0.25rem;
          border-left: 2px solid var(--error);
        }
      }
    </style>

    <div id="binary-wrapper">
      <output id="binary" :ref="binaryEl" :fx="binaryEl.innerHTML = binaryHtml" title="WebAssembly WASM binary" aria-label="WebAssembly WASM binary" lang="plaintext"></output>
    </div>
    <style>
      #binary-wrapper {
        flex: 1;
        min-width: 0;
        overflow: auto;
        display: flex;
        justify-content: center;
      }

      #binary {
        position: relative;
        max-width: 80ch;
        word-wrap: break-word;
        overflow-wrap: break-word;
      }

      #binary.flash {
        animation: flash 0.3s ease-out;
      }

      @keyframes flash {
        0% { opacity: 0.4; }
        100% { opacity: 1; }
      }

      .preamble {
        color: var(--comment);
      }

      .type {
        color: var(--keyword);
      }

      .import {
        color: var(--id);
      }

      .func {
        color: var(--keyword)
      }

      .table {
        color: var(--number);
      }

      .memory {
        color: var(--keyword);
      }

      .global {
        color: var(--id);
      }

      .export {
        color: var(--number);
      }

      .start {
        color: var(--annot);
      }

      .elem {
        color: var(--keyword);
      }

      .datacount {
        color: var(--comment);
      }

      .code {}

      .data {
        color: var(--data);
      }
    </style>
  </div>


  <output id="log" :ref="logEl" :fx="logEl.innerHTML = logHtml" :onclick="scrollToError" :style="{ color: error ? 'var(--error)' : 'var(--success)' }"></output>
  <style>
    #log {
      padding: 2rem 1rem 1rem;
      position: fixed;
      bottom: 0;
      right: 0;
      left: 0;
      text-align: left;
      background: linear-gradient(to top, white 50%, rgba(255, 255, 255, 0) 100%);
    }
    .err-loc {
      cursor: pointer;
      text-decoration: underline;
      text-decoration-color: color-mix(in srgb, currentColor 27%, transparent);
      text-underline-offset: 3px;
    }
    .err-loc:hover {
      text-decoration-color: currentColor;
    }
  </style>

  <script type="module">
    import sprae from './lib/sprae.js'
    import Codejar from './lib/codejar.js'
    import { compile as watrCompile, print } from '../watr.js'

    const SECTION = 'custom type import func table memory global export start elem code data datacount'.split(' ')

    // Gzip compression utilities
    async function gzipEncode(text) {
      const encoder = new TextEncoder()
      const data = encoder.encode(text)
      const cs = new CompressionStream('gzip')
      const writer = cs.writable.getWriter()
      writer.write(data)
      writer.close()

      const buf = []
      const reader = cs.readable.getReader()
      try {
        while (true) {
          const { done, value } = await reader.read()
          if (done) break
          buf.push(...value)
        }
      } finally {
        reader.releaseLock()
      }

      return btoa(String.fromCharCode(...buf))
    }

    async function gzipDecode(encoded) {
      const binaryStr = atob(encoded)
      const bytes = new Uint8Array(binaryStr.length)
      for (let i = 0; i < binaryStr.length; i++) {
        bytes[i] = binaryStr.charCodeAt(i)
      }

      const ds = new DecompressionStream('gzip')
      const writer = ds.writable.getWriter()
      writer.write(bytes)
      writer.close()

      const buf = []
      const reader = ds.readable.getReader()
      try {
        while (true) {
          const { done, value } = await reader.read()
          if (done) break
          buf.push(...value)
        }
      } finally {
        reader.releaseLock()
      }

      return new TextDecoder().decode(new Uint8Array(buf))
    }

    // available compilers
    const compilers = {
      async watr(code) { return watrCompile(code) },

      async wabt(code) {
        if (!compilers.wabt.compile) {
          let { default: Wabt } = await import('../test/lib/wabt.js')
          compilers.wabt.compile = await new Wabt()
        }
        const wabt = compilers.wabt.compile
        const module = wabt.parseWat('inline', code, {
          "exceptions": true,
          "mutable_globals": true,
          "sat_float_to_int": true,
          "sign_extension": true,
          "simd": true,
          "threads": true,
          "function_references": true,
          "multi_value": true,
          "tail_call": true,
          "bulk_memory": true,
          "reference_types": true,
          "annotations": true,
          "code_metadata": true,
          "gc": true,
          "memory64": true,
          "multi_memory": true,
          "extended_const": true,
          "relaxed_simd": true
        })
        return module.toBinary({
          log: false,
          canonicalize_lebs: true,
          relocatable: false,
          write_debug_names: false
        }).buffer
      },

      async wast(code) {
        if (!globalThis.WebAssemblyText) await import('../test/lib/wast.js')
        return WebAssemblyText.encode(code, { metrics: false })
      },

      async watc(code) {
        if (!compilers.watc.compile) compilers.watc.compile = (await import('../test/lib/wat-compiler.js')).default
        return compilers.watc.compile(code, { metrics: false }).buffer
      },

      async binaryen(code) {
        if (!compilers.binaryen.instance) {
          compilers.binaryen.instance = (await import('../test/lib/binaryen.js')).default
        }
        const binaryen = compilers.binaryen.instance
        const module = binaryen.parseText(code)
        const result = module.emitBinary()
        module.dispose()
        return result
      }
    }

    // Minimal WAT syntax highlighter
    const highlight = (editor) => {
      const text = editor.textContent
      editor.innerHTML = text
        .replace(/\(([\w$.]+)/g, '(<span class="kw">$1</span>')
        .replace(/(\$[^\s(){}[\];,"]+)/g, '<span class="var">$1</span>')
        .replace(/(;;.*)$/gm, '<span class="comment">$1</span>')
        .replace(/(\(;.*;\))$/gm, '<span class="comment">$1</span>')
        .replace(/(@\w+)/g, '<span class="annot">$1</span>')
        .replace(/(\\[\da-z][\da-z])/ig, '<span class="data">$1</span>')
        .replace(/(?<!\\)(\b(?:0x)?\d[\d_a-z]*\b)/ig, '<span class="num">$1</span>')
    }

    // parse unsigned LEB128
    function uleb(bytes, offset = 0) {
      let result = 0, shift = 0, byte
      do {
        byte = bytes[offset++]
        result |= (byte & 0x7F) << shift
        shift += 7
      } while (byte & 0x80)
      return [result, offset]
    }

    function hex(arr) {
      return Array.from(arr).map(c => c.toString(16).padStart(2, 0)).join(' ')
    }

    // format buffer into highlighted hex string
    function hihex(buf) {
      let bytes = new Uint8Array(buf)
      let result = ''
      let offset = 8

      result += `<p class="section preamble" title="preamble">${hex(bytes.slice(0, 8))}</p>`

      while (offset < bytes.length) {
        const id = bytes[offset++]
        if (!SECTION[id]) throw new Error(`Bad section ${id}`)

        result += `<p title="${SECTION[id]}" class="section ${SECTION[id]}">`
        result += ` <b title="${SECTION[id]} id: ${id}">${hex([id])}</b>`
        const [size, newOffset] = uleb(bytes, offset)
        result += ` <i title="${SECTION[id]} size: ${size}">${hex(bytes.slice(offset, newOffset))}</i> `
        result += `<br/>`
        result += hex(bytes.slice(newOffset, offset = newOffset + size))
        result += `</p>`
      }
      return result
    }

    // Reactive state - sprae returns the reactive proxy
    let codejar = null
    let buf = null
    let timeout = null
    let state = null
    let loadingExample = false // Flag to prevent MutationObserver from resetting example

    // Load example by name
    async function loadExample(name) {
      state.example = name
      if (!name) return // Custom - keep current code
      loadingExample = true
      const code = await fetch(`../test/example/${name}.wat`).then(r => r.text())
      codejar.updateCode(code)
      state.sourceCode = code
      state.prettified = false
      // Update URL to short example format
      history.replaceState(null, '', `#${name}`)
      // Delay resetting flag until after MutationObserver callbacks have fired
      setTimeout(() => { loadingExample = false }, 0)
      state.recompile()
    }

    // Load file from File object (used by file input and drag-drop)
    async function handleFile(file) {
      if (!file) return
      try {
        let code
        const ext = file.name.split('.').pop().toLowerCase()

        if (ext === 'wasm') {
          // Binary: convert to WAT using wabt
          const buffer = await file.arrayBuffer()
          if (!compilers.wabt.compile) {
            let { default: Wabt } = await import('../test/lib/wabt.js')
            compilers.wabt.compile = await new Wabt()
          }
          const wabt = compilers.wabt.compile
          const module = wabt.readWasm(new Uint8Array(buffer), { readDebugNames: true })
          code = module.toText({ foldExprs: false, inlineExport: true })
          module.destroy()
        } else {
          // Text: read as-is (.wat, .wast)
          code = await file.text()
        }

        loadingExample = true
        codejar.updateCode(code)
        state.sourceCode = code
        state.example = '' // Custom
        state.prettified = false
        setTimeout(() => { loadingExample = false }, 0)
        state.recompile()
        state.logHtml = `Loaded ${file.name}`
      } catch (err) {
        state.logHtml = `Error loading file: ${err.message}`
        state.error = true
      }
    }

    state = sprae(document.getElementById('app'), {
      compiler: 'watr',
      example: 'hello',
      sourceCode: '',
      binaryHtml: '',
      logHtml: '',
      error: false,
      errorLine: null, // Line number with error (1-based)
      prettified: false,
      binaryEl: null,
      logEl: null,
      loadBinaryInput: null,
      lineNumbersEl: null,
      urlHashTimeout: null,

      loadExample, // expose to template

      // Update line numbers display
      updateLineNumbers() {
        if (!state.lineNumbersEl) return
        const lines = (state.sourceCode || '').split('\n').length
        state.lineNumbersEl.textContent = Array.from({ length: lines }, (_, i) => i + 1).join('\n')
      },

      // Edit line(s) with transform function, restore cursor/selection
      editLine(fn) {
        const el = document.getElementById('source')
        const sel = window.getSelection()
        if (!sel.rangeCount) return

        const text = el.textContent
        const range = sel.getRangeAt(0)

        // Get selection boundaries
        const preStart = document.createRange()
        preStart.selectNodeContents(el)
        preStart.setEnd(range.startContainer, range.startOffset)
        const selStart = preStart.toString().length

        const preEnd = document.createRange()
        preEnd.selectNodeContents(el)
        preEnd.setEnd(range.endContainer, range.endOffset)
        const selEnd = preEnd.toString().length

        // Find line boundaries for selection
        const lineStart = text.lastIndexOf('\n', selStart - 1) + 1
        const lineEnd = text.indexOf('\n', selEnd - 1)
        const selectedText = text.slice(lineStart, lineEnd < 0 ? undefined : lineEnd)

        // Transform each line
        const lines = selectedText.split('\n')
        const newLines = lines.map(fn)
        const newText = text.slice(0, lineStart) + newLines.join('\n') + text.slice(lineStart + selectedText.length)

        // Calculate delta for cursor restoration
        // Cursor moves with indentation on current line too
        let deltaStart = 0, deltaEnd = 0
        for (let i = 0, pos = lineStart; i < lines.length; i++) {
          const lineDelta = newLines[i].length - lines[i].length
          // Include delta if cursor is on or past this line
          if (selStart > pos) deltaStart += lineDelta
          if (selEnd > pos) deltaEnd += lineDelta
          pos += lines[i].length + 1
        }

        codejar.updateCode(newText)
        state.sourceCode = newText
        state.example = '' // Custom
        state.updateUrlHash() // Update URL when editing

        // Restore selection
        const newStart = Math.max(lineStart, selStart + deltaStart)
        const newEnd = Math.max(lineStart, selEnd + deltaEnd)
        requestAnimationFrame(() => {
          const sel = window.getSelection()
          const range = document.createRange()
          const walker = document.createTreeWalker(el, NodeFilter.SHOW_TEXT)
          let pos = 0, startNode, startOff, endNode, endOff
          while (walker.nextNode()) {
            const len = walker.currentNode.length
            if (!startNode && pos + len >= newStart) {
              startNode = walker.currentNode
              startOff = newStart - pos
            }
            if (pos + len >= newEnd) {
              endNode = walker.currentNode
              endOff = newEnd - pos
              break
            }
            pos += len
          }
          if (startNode) {
            range.setStart(startNode, startOff)
            range.setEnd(endNode || startNode, endOff ?? startOff)
            sel.removeAllRanges()
            sel.addRange(range)
          }
        })
      },

      // Handle keyboard shortcuts
      handleKey(e) {
        if (e.key === '/') {
          e.preventDefault()
          state.toggleComment()
        } else if (e.key === ']') {
          e.preventDefault()
          state.editLine(line => '  ' + line)
        } else if (e.key === '[') {
          e.preventDefault()
          state.editLine(line => line.replace(/^ {1,2}/, ''))
        } else if (e.key === 'Enter') {
          e.preventDefault()
          state.compile()
        }
      },

      // Toggle comments: uncomment only if ALL lines are commented
      toggleComment() {
        const el = document.getElementById('source')
        const sel = window.getSelection()
        if (!sel.rangeCount) return

        const text = el.textContent
        const range = sel.getRangeAt(0)

        // Get selection boundaries
        const preStart = document.createRange()
        preStart.selectNodeContents(el)
        preStart.setEnd(range.startContainer, range.startOffset)
        const selStart = preStart.toString().length

        const preEnd = document.createRange()
        preEnd.selectNodeContents(el)
        preEnd.setEnd(range.endContainer, range.endOffset)
        const selEnd = preEnd.toString().length

        // Find line boundaries
        const lineStart = text.lastIndexOf('\n', selStart - 1) + 1
        const lineEnd = text.indexOf('\n', selEnd - 1)
        const selectedText = text.slice(lineStart, lineEnd < 0 ? undefined : lineEnd)
        const lines = selectedText.split('\n')

        // Check if ALL non-empty lines are commented
        const allCommented = lines.every(line => !line.trim() || line.trimStart().startsWith(';;'))
        const fn = allCommented
          ? line => line.replace(/^(\s*);; ?/, '$1')  // uncomment
          : line => line.trim() ? line.replace(/^(\s*)/, '$1;; ') : line  // comment (skip empty)

        const newLines = lines.map(fn)
        const newText = text.slice(0, lineStart) + newLines.join('\n') + text.slice(lineStart + selectedText.length)

        // Calculate delta for cursor restoration
        let deltaStart = 0, deltaEnd = 0
        for (let i = 0, pos = lineStart; i < lines.length; i++) {
          const lineDelta = newLines[i].length - lines[i].length
          if (selStart > pos) deltaStart += lineDelta
          if (selEnd > pos) deltaEnd += lineDelta
          pos += lines[i].length + 1
        }

        codejar.updateCode(newText)
        state.sourceCode = newText
        state.example = '' // Custom
        state.updateUrlHash() // Update URL when editing

        // Restore selection
        const newStart = Math.max(lineStart, selStart + deltaStart)
        const newEnd = Math.max(lineStart, selEnd + deltaEnd)
        requestAnimationFrame(() => {
          const sel = window.getSelection()
          const range = document.createRange()
          const walker = document.createTreeWalker(el, NodeFilter.SHOW_TEXT)
          let pos = 0, startNode, startOff, endNode, endOff
          while (walker.nextNode()) {
            const len = walker.currentNode.length
            if (!startNode && pos + len >= newStart) {
              startNode = walker.currentNode
              startOff = newStart - pos
            }
            if (pos + len >= newEnd) {
              endNode = walker.currentNode
              endOff = newEnd - pos
              break
            }
            pos += len
          }
          if (startNode) {
            range.setStart(startNode, startOff)
            range.setEnd(endNode || startNode, endOff ?? startOff)
            sel.removeAllRanges()
            sel.addRange(range)
          }
        })
      },

      // Handle file input change
      async loadFile(e) {
        await handleFile(e.target.files[0])
        e.target.value = '' // Reset input for re-selecting same file
      },

      // Handle drag-drop
      handleDrop(e) {
        e.preventDefault()
        document.body.classList.remove('dragover')
        const file = e.dataTransfer.files[0]
        if (file) handleFile(file)
      },

      handleDragOver(e) {
        e.preventDefault()
        document.body.classList.add('dragover')
      },

      handleDragLeave(e) {
        e.preventDefault()
        document.body.classList.remove('dragover')
      },

      // Get shareable URL with gzip-compressed code
      async getShareUrl() {
        if (!state.sourceCode) return window.location.href
        try {
          const encoded = await gzipEncode(state.sourceCode)
          return `${window.location.origin}${window.location.pathname}#code=${encoded}`
        } catch (e) {
          console.error('Failed to generate share URL:', e)
          return window.location.href
        }
      },

      // Update URL hash with current code (debounced)
      async updateUrlHash() {
        clearTimeout(state.urlHashTimeout)
        state.urlHashTimeout = setTimeout(async () => {
          if (state.example) {
            // If it's a known example, use short URL
            history.replaceState(null, '', `#${state.example}`)
          } else if (state.sourceCode) {
            // Otherwise, compress and serialize code
            try {
              const encoded = await gzipEncode(state.sourceCode)
              history.replaceState(null, '', `#code=${encoded}`)
            } catch (e) {
              console.error('Failed to update URL hash:', e)
            }
          }
        }, 500)
      },

      // Initialize codejar editor
      initEditor(el) {
        codejar = Codejar(el, highlight, {
          tab: '  ',
          indentOn: /{/,
          spellcheck: false,
          catchTabs: true,
          history: true,
        })

        // Watch for changes
        codejar.onUpdate(code => {
          state.sourceCode = code
          state.updateLineNumbers()
          if (!loadingExample) {
            state.example = '' // Switch to Custom when user edits
            state.updateUrlHash() // Update URL as user types
          }
          state.recompile()
        })

        // Sync scroll between editor and line numbers
        el.addEventListener('scroll', () => {
          if (state.lineNumbersEl) state.lineNumbersEl.scrollTop = el.scrollTop
        })

        // Load initial example or code from URL hash
        queueMicrotask(async () => {
          const hash = location.hash.slice(1)

          // Check for #example=name format (short URLs)
          if (hash && !hash.startsWith('code=')) {
            try {
              loadingExample = true
              await loadExample(hash)
              state.example = hash
            } catch (e) {
              console.error('Failed to load example:', e)
              loadExample('hello')
            } finally {
              loadingExample = false
            }
          }
          // Check for #code=... format (gzipped code)
          else if (hash.startsWith('code=')) {
            try {
              loadingExample = true
              const code = await gzipDecode(hash.slice(5))
              codejar.updateCode(code)
              state.sourceCode = code
              state.example = '' // Custom
              state.prettified = false
              state.updateLineNumbers()
              state.recompile()
            } catch (e) {
              console.error('Failed to load code from URL:', e)
              loadExample('hello')
            } finally {
              loadingExample = false
            }
          }
          // Otherwise load default
          else {
            loadExample('hello')
          }
        })
      },

      // Highlight error line in editor (preserves caret position)
      highlightErrorLine(lineNum) {
        if (!lineNum) return
        const el = document.getElementById('source')

        // Save caret position
        const sel = window.getSelection()
        let caretOffset = 0
        if (sel.rangeCount && el.contains(sel.anchorNode)) {
          const range = document.createRange()
          range.selectNodeContents(el)
          range.setEnd(sel.anchorNode, sel.anchorOffset)
          caretOffset = range.toString().length
        }

        // Apply error highlight
        const lines = el.innerHTML.split('\n')
        if (lineNum > 0 && lineNum <= lines.length) {
          lines[lineNum - 1] = `<span class="error-line">${lines[lineNum - 1]}</span>`
          el.innerHTML = lines.join('\n')
        }

        // Restore caret position
        if (caretOffset > 0) {
          const walker = document.createTreeWalker(el, NodeFilter.SHOW_TEXT)
          let pos = 0, node
          while (walker.nextNode()) {
            node = walker.currentNode
            if (pos + node.length >= caretOffset) {
              const range = document.createRange()
              range.setStart(node, caretOffset - pos)
              range.collapse(true)
              sel.removeAllRanges()
              sel.addRange(range)
              break
            }
            pos += node.length
          }
        }
      },

      // Clear error highlighting
      clearErrorHighlight() {
        state.errorLine = null
        // Re-highlight without error marks (codejar will handle this on next update)
      },

      // Scroll to error line when clicking on error log
      scrollToError() {
        if (!state.error || !state.errorLine) return
        const el = document.getElementById('source')
        const wrapper = document.getElementById('editor-wrapper')
        const lineHeight = parseFloat(getComputedStyle(el).lineHeight) || 16
        const targetScroll = (state.errorLine - 1) * lineHeight - wrapper.clientHeight / 3
        wrapper.scrollTo({ top: Math.max(0, targetScroll), behavior: 'smooth' })
        // Focus editor and place cursor at error line
        el.focus()
      },

      // Debounced recompile
      recompile() {
        clearTimeout(timeout)
        state.logHtml = ''
        state.clearErrorHighlight()
        state.updateLineNumbers()
        if (!state.sourceCode) state.binaryHtml = ''
        timeout = setTimeout(() => state.compile(), 300)
      },

      // Compile source code
      async compile() {
        state.binaryHtml = ''
        state.logHtml = ''
        state.error = false
        state.errorLine = null

        if (!state.sourceCode.trim()) return

        try {
          const start = performance.now()
          buf = await compilers[state.compiler](state.sourceCode)
          const end = performance.now()

          state.binaryHtml = hihex(buf)
          state.logHtml = `Compiled in ${(end - start).toFixed(2)} ms`
          state.error = false

          // Flash animation on update
          state.binaryEl.classList.remove('flash')
          void state.binaryEl.offsetWidth // reflow to restart animation
          state.binaryEl.classList.add('flash')

          // Try to instantiate
          const mod = new WebAssembly.Module(buf)
          try {
            const instance = new WebAssembly.Instance(mod, {})
            console.log(instance)
          } catch (e) {
            console.warn(e)
          }
        } catch (e) {
          console.error(e)
          // Wrap line:col in clickable underlined span
          state.logHtml = String(e).replace(/at (\d+:\d+)/, 'at <span class="err-loc">$1</span>')
          state.error = true

          // Parse error line from "at line:col" format
          const match = String(e).match(/at (\d+):(\d+)/)
          if (match) {
            state.errorLine = parseInt(match[1], 10)
            state.highlightErrorLine(state.errorLine)
          }
        }
      },

      // Download WASM binary
      download() {
        if (!buf) return
        const blob = new Blob([buf], { type: 'application/wasm' })
        const url = URL.createObjectURL(blob)
        const a = document.createElement('a')
        a.href = url
        a.download = 'module.wasm'
        a.type = 'application/wasm'
        a.click()
        URL.revokeObjectURL(url)
      },

      // Copy binary as base64
      copyBase64() {
        if (!buf) return
        const base64 = btoa(String.fromCharCode(...buf))
        navigator.clipboard.writeText(base64)
      },

      // Toggle between prettify/minify
      toggleFormat() {
        if (state.prettified) {
          // Already prettified, now minify (warning: loses comments)
          const code = print(state.sourceCode, { indent: false, newline: false, comments: false })
          codejar.updateCode(code)
          state.sourceCode = code
          state.prettified = false
        } else {
          // Prettify first (keeps comments)
          const code = print(state.sourceCode)
          codejar.updateCode(code)
          state.sourceCode = code
          state.prettified = true
        }
        state.updateUrlHash()
      }
    })

    // Expose for debugging/testing
    window.state = state
  </script>

  <footer style="position: absolute; bottom: 1rem; right: 1rem; z-index: 2;">
    <a href="https://github.com/krishnized/license" title="License (MIT, Krishnized)">‡•ê</a>
  </footer>
</body>
